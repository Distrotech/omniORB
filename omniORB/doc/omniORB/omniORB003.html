<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.06">
<TITLE>
 C++ language mapping
</TITLE>
</HEAD>
<BODY >
<A HREF="omniORB002.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC ="contents_motif.gif" ALT="Up"></A>
<A HREF="omniORB004.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
<HR>

<H1><A NAME="htoc40">Chapter&nbsp;3</A>&nbsp;&nbsp;C++ language mapping</H1>

Now that you are familiar with the basics, it is important to
familiarise yourself with the standard IDL to C++ language mapping.
The mapping is described in detail in&nbsp;[<A HREF="omniORB013.html#cxxmapping"><CITE>OMG03</CITE></A>]. If you have
not done so, you should obtain a copy of the document and use that as
the programming guide to omniORB.<BR>
<BR>
The specification is not an easy read. The alternative is to use one
of the books on CORBA programming that has begun to appear. For
instance, Henning and Vinoski's `Advanced CORBA Programming with
C++'&nbsp;[<A HREF="omniORB013.html#henning1999"><CITE>HV99</CITE></A>] includes many example code bits to illustrate
how to use the C++ mapping.<BR>
<BR>
<A NAME="toc16"></A>
<H2><A NAME="htoc41">3.1</A>&nbsp;&nbsp;omniORB 2 BOA compatibility</H2>
<A NAME="sec:BOAcompat"></A>
If you use the <TT>-WbBOA</TT> option to omniidl, it will generate
skeleton code with the same interface as the old omniORB 2 BOA
mapping, as well as code to be used with the POA. Note that since the
major problem with the BOA specification was that server code was not
portable between ORBs, it is unlikely that omniORB 4.0's BOA
compatibility will help you much if you are moving from a different
BOA-based ORB.<BR>
<BR>
The BOA compatibility permits the majority of BOA code to compile
without difficulty. However, there are a number of constructs which
relied on omniORB 2 implementation details which no longer work.
<UL><LI>omniORB 2 did not use distinct types for object references and
servants, and often accepted a pointer to a servant when the CORBA
specification says it should only accept an object reference. Such
code will not compile under omniORB 4.0.<BR>
<BR>
<LI>The reverse is true for <TT>BOA::obj_is_ready()</TT>. It now only
works when passed a pointer to a servant object, not an object
reference. The more commonly used mechanism of calling
<TT>_obj_is_ready(boa)</TT> on the servant object still works as
expected.<BR>
<BR>
<LI>It used to be the case that the skeleton class for interface
<TT>I</TT> (<TT>_sk_I</TT>) was derived from class <TT>I</TT>. This meant
that the names of any types declared in the interface were available
in the scope of the skeleton class. This is no longer true. If you
have an interface:
<PRE>
interface I {
  struct S {
    long a,b;
  };
  S op();
};
</PRE>
then where before the implementation code might have been:
<PRE>
class I_impl : public virtual _sk_I {
  S op();  // _sk_I is derived from I
};
I::S I_impl::op() {
  S ret;
  // ...
}
</PRE>
it is now necessary to fully qualify all uses of <TT>S</TT>:
<PRE>
class I_impl : public virtual _sk_I {
  I::S op(); // _sk_I is not derived from I
};
I::S I_impl::op() {
  I::S ret;
  // ...
}
</PRE><BR>
<BR>
<LI>The proprietary omniORB 2 LifeCycle extensions are no longer
supported. All of the facilities it offered can be implemented with
the POA interfaces, and the <TT>omniORB::LOCATION_FORWARD</TT>
exception (see section&nbsp;<A HREF="omniORB004.html#sec:locationForward">4.854Location forwardingsection.4.8</A>). Code which used the
old interfaces will have to be rewritten.</UL>
<A NAME="toc17"></A>
<H2><A NAME="htoc42">3.2</A>&nbsp;&nbsp;omniORB 3.0 compatibility</H2>
omniORB 4.0 is almost completely source-code compatible with omniORB
3.0. There are two main cases where code may have to change. The first
is code that uses the omniORB API, some aspects of which have
changed. The omniORB configuration file also has a new format. See the
next chapter for details of the new API and configuration file.<BR>
<BR>
The second case of code that may have to change is code using the
Dynamic Any interfaces. The standard changed quite significantly
between CORBA 2.2 and CORBA 2.3; omniORB 3.0 supported the old CORBA
2.2 interfaces; omniORB 4.0 uses the new mapping. The changes are
largely syntax changes, rather than semantic differences.<BR>
<BR>
<HR>
<A HREF="omniORB002.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC ="contents_motif.gif" ALT="Up"></A>
<A HREF="omniORB004.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
